
# FPAA Flood Fill

## Descri√ß√£o
Este projeto realiza a implementa√ß√£o e demonstra√ß√£o de um algoritmo Flood Fill para identifica√ß√£o e preenchimento de regi√µes conectadas em um grid 2D.
Ele tem como objetico, fornecer uma ferramenta simples em Python para detectar e preencher regi√µes conectadas (componentes) em uma matriz bidimensional, com uma interface m√≠nima para teste e visualiza√ß√£o.

## Introdu√ß√£o

## Instru√ß√µes de Uso e Configura√ß√£o
- **Requisitos:**
  - Python 3.8+ instalado

- **Como executar:**
  1. Navegue at√© a pasta do projeto:

	  `cd c:\Users\eduado\Desktop\fpaa-floodfill`

  2. Instale depend√™ncias. Este projeto √© escrito em Python puro e n√£o tem depend√™ncias externas obrigat√≥rias, ent√£o normalmente n√£o √© necess√°rio instalar pacotes extras.

  3. Para rodar a aplica√ß√£o principal:

	  `python src\main.py`

  4. Arquivos principais:
	  - `src\floodfill.py` ‚Äî implementa√ß√£o do algoritmo Flood Fill.
	  - `src\gui.py` ‚Äî interface m√≠nima para testar/visualizar.
	  - `src\main.py` ‚Äî arquivo principal do programa.

---

## Explica√ß√£o do Algoritmo Flood Fill

O algoritmo segue uma abordagem **iterativa baseada em fila (BFS)**, garantindo que cada c√©lula naveg√°vel (`0`) seja agrupada de acordo com sua conectividade ortogonal (cima, baixo, esquerda e direita). Obst√°culos (`1`) s√£o preservados, e cada regi√£o encontrada recebe uma cor num√©rica distinta (`2‚Äì9`).

O funcionamento est√° organizado em tr√™s partes principais: detec√ß√£o de vizinhos, preenchimento de uma √∫nica regi√£o e preenchimento completo de todas as regi√µes do grid.

---

### 1. A fun√ß√£o `_vizinhos`

```python
def _vizinhos(x, y, num_linhas, num_colunas):
```

Retorna todos os vizinhos **ortogonais v√°lidos**, respeitando os limites da grade.
Apenas as posi√ß√µes imediatamente adjacentes s√£o consideradas ‚Äî diagonais n√£o contam como conex√£o.

**Exemplo: Ponto (2,1) em um grid 5√ó5:**

- Os vizinhos ortogonais v√°lidos seriam:
   - Esquerda: **(1,1)**
   - Direita: **(3,1)**
   - Cima: **(2,0)**
   - Baixo: **(2,2)**

* Representa√ß√£o visual dos vizinhos:

```
      (2,0)
        ‚Üë
(1,1) ‚Üê X ‚Üí (3,1)
        ‚Üì
      (2,2)
```

---

### 2. A fun√ß√£o `preencher_regiao`

Essa fun√ß√£o executa o Flood Fill de fato, utilizando uma **fila (deque)** para implementar BFS.

**Passo a passo:**

- Verifica se o grid √© v√°lido.
- Verifica se a posi√ß√£o inicial est√° dentro dos limites.
- Confirma que a c√©lula inicial possui o valor-alvo (`0`).
- Insere essa c√©lula na fila e altera seu valor para o r√≥tulo adequado (a cor da regi√£o).
- Enquanto a fila n√£o estiver vazia:
   - remove uma c√©lula atual
   - verifica cada vizinho retornado por `_vizinhos`
   - se o vizinho possui o valor-alvo, ele √© pintado e adicionado √† fila

* Isso garante que todas as c√©lulas conectadas e naveg√°veis sejam preenchidas.

### Exemplo do funcionamento de `preencher_regiao`

**Entrada:**

```
0 0 1
0 1 1
1 1 1
```

**Chamada:**

```python
preencher_regiao(grade, 0, 0, rotulo=2)
```

**Execu√ß√£o:**

- **(0,0)** ‚Üí √© livre **(0)**, ent√£o recebe **2**
- Vizinhos ortogonais:
   - **(1,0)** ‚Üí de **0** ‚Üí √© atualizado para **2**
   - **(0,1)** ‚Üí de **0** ‚Üí √© atualizado para **2**

* Todos os outros vizinhos s√£o `1` (obst√°culo), portanto o preenchimento encerra **nesse ponto**.
* Nenhuma outra c√©lula livre est√° conectada ao ponto inicial.

**Resultado:**

```
2 2 1
2 1 1
1 1 1
```

- A fun√ß√£o retorna `True` indicando que a regi√£o foi preenchida.

---

### 3. A fun√ß√£o `preencher_todas_regioes`

Essa fun√ß√£o coordena o preenchimento global do grid. Ela:

- Define um contador de cor que varia entre **2 e 9**, retornando para 2 ap√≥s 9.
- Preenche a primeira regi√£o a partir da c√©lula inicial.
- Percorre o grid totalmente (linha por linha):
   - toda vez que encontra um `0`, avan√ßa para a pr√≥xima cor e chama `preencher_regiao` novamente

Com isso:

- cada conjunto de c√©lulas conectadas recebe um r√≥tulo diferente
- obst√°culos (`1`) s√£o preservados
- regi√µes coloridas (`>= 2`) n√£o s√£o alteradas

### Exemplo completo usando o algoritmo

**Grade inicial:**
```
0 1 0
0 1 0
1 1 1
```

- Primeira c√©lula livre encontrada: **(0,0)**
- Primeira regi√£o ‚Üí recebe a cor **2**:

**Primeira regi√£o preenchida:**
```
2 1 0
2 1 0
1 1 1
```

- O algoritmo continua percorrendo o grid e encontra novo `0` em **(2,0)**.
   - Nova cor: **3**

**Segunda regi√£o preenchida:**
```
2 1 3
2 1 3
1 1 1
```

- Nenhuma c√©lula livre restante, fim do processo.

---

### 4. A fun√ß√£o `estatisticas_regioes`

Essa fun√ß√£o percorre o grid e conta quantas c√©lulas pertencem a cada cor (`>= 2`).

**Exemplo:**
```
2 2 1 3
2 1 1 3
1 4 4 1
```

**Estat√≠sticas:**
```
Cor 2 ‚Üí 3 c√©lulas
Cor 3 ‚Üí 2 c√©lulas
Cor 4 ‚Üí 2 c√©lulas
```

---

### 5. Visualiza√ß√£o com Tkinter (GUI)

O m√≥dulo `InterfaceGrade` exibe o grid visualmente:

- cada c√©lula √© desenhada como um ret√¢ngulo colorido
- as cores seguem o dicion√°rio `CORES`
- a interface √© atualizada a cada altera√ß√£o no grid

**Exemplo de convers√£o:**
```
2 2 1 3 3
```

- Representa√ß√£o visual:
```
üü• üü• ‚¨õ üüß üüß
```
---

### 6. Execu√ß√£o principal (MAIN.PY)

O arquivo `main` integra todas as partes do projeto:

**1.** Carrega o grid inicial.
**2.** Encontra a primeira c√©lula livre.
**3.** Exibe o grid original no terminal.
**4.** Inicia a interface gr√°fica.
**5.** Executa `preencher_todas_regioes`.
**6.** Mostra o grid final.
**7.** Exibe estat√≠sticas de cada regi√£o.
**8.** Atualiza a interface para mostrar o resultado colorido.

**Exemplo de sa√≠da no terminal:**
```
Regi√µes preenchidas: 5
Cor 2: 10 c√©lulas
Cor 3: 7 c√©lulas
Cor 4: 12 c√©lulas
...
```
---
